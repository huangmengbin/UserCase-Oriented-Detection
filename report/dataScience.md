# 数据科学基础大作业
<!-- TOC -->

- [数据科学基础大作业](#数据科学基础大作业)
    - [一、小组信息：](#一小组信息)
        - [1.小组人数： 3人](#1小组人数-3人)
        - [2.成员信息](#2成员信息)
    - [二、研究问题：“面向用例”检测](#二研究问题面向用例检测)
        - [1.研究背景](#1研究背景)
        - [2.应用场景](#2应用场景)
        - [3.研究思路](#3研究思路)
    - [三、代码说明](#三代码说明)
        - [1.代码开源地址](#1代码开源地址)
        - [2.代码目录说明](#2代码目录说明)
    - [四、研究方法](#四研究方法)
        - [字符串模糊匹配法](#字符串模糊匹配法)
            - [1.数据获取](#1数据获取)
                - [代码数据抽取](#代码数据抽取)
                - [样例数据加工](#样例数据加工)
            - [2.数据匹配](#2数据匹配)
            - [3.数据处理](#3数据处理)
        - [if_else分析法](#if_else分析法)
            - [1.数据获取](#1数据获取-1)
            - [2.分析矩阵](#2分析矩阵)
    - [五、其他的工具包](#五其他的工具包)
        - [1.时间限制](#1时间限制)
        - [2.gui展示](#2gui展示)
    - [六、使用的自带库or开源库](#六使用的自带库or开源库)
    - [七、案例分析](#七案例分析)
    - [八、本项目的优势与局限](#八本项目的优势与局限)
        - [优势](#优势)
        - [局限](#局限)
    - [九、想说的话](#九想说的话)
    - [附录](#附录)

<!-- /TOC -->
## 一、小组信息：

### 1.小组人数： 3人
### 2.成员信息
	181250051_黄孟斌_181250051@smail.nju.edu.cn  Python完成题数185  
	json数据格式转换、删除重复测试样例文件、提取代码里面的常量数据、字符串模糊匹配 、if_else结构分析、gui界面、数据可视化、报告、视频
	
	181250029_段晓文_181250029@smail.nju.edu.cn  Python完成题数177  
	ppt、数据可视化、展示代码里面的常量数据  
	
	181250179_袁易锋_181250179@smail.nju.edu.cn  Python完成题数200 
	报告、数据下载、数据解压缩、if_else结构分析  


## 二、研究问题：“面向用例”检测

### 1.研究背景
- 在本次的200道Python练习题中，因为结果显示中可以看到正确的答案，所以就可以通过简单的方法来获取一对对的用例和相应的结果，在这样的情况下就可以通过判断来确定一个输入对应的是什么答案。这就是“面向用例”编程。  
- 在某些情况下，把所有用例都放出来有利于同学们进行编程、debug。尤其是算法题太多太难，不知道bug在哪里容易让学生产生自闭的情绪  
- 放出用例是有必要的，尤其是有的测试用例本身就有错漏。不放出用例，学生不知道用例有误，很可能拼命寻找本不存在的bug，知道真相后可能导致精神崩溃  
- 但放出用例给予了钻空子的可能。而面向用例编程是我们不愿意看到的，它不能反映同学们的正常水平，也浪费同学们的时间  
- 我们组本次的研究问题就是通过一定的方法来检测出这些“面向用例”的代码  

### 2.应用场景
- 分析同学们的代码，查看出同学们有没有用“面向用例”的方法来投机取巧，为了通过测试不择手段  
- 限制下一届筒子进行面向用例编程，使得助教xggxjj们能够继续把用例放出来，提升筒子们写代码的体验；同时也让同学们能真正锻炼到编码能力

### 3.研究思路

- (1).面向用例的代码本质特征是：源代码重有大量与测试样例重合的部分。因此可以尝试源代码与测试样例文本的信息相似度匹配。
      这样进行匹配之后的结果是基本准确的。

- (2).除了文本的信息相似度匹配之外，我们还设计了if else的结构分析，因为本次作业大部分面向用例的都是采用简单if else的方法。列如下面这段代码：
```python
(n, m) = [int(i) for i in input().split()]
l = []
for frf in range(m):
    l.append(input())
if (l[0] == '394 640'):
    print(274)
elif (l[0] == '456 912'):
    print(380)
elif (l[0] == '936 144'):
    print(554)
elif (l[0] == '1 0'):
    print(3)
elif (l[0] == '3 2'):
    print(4)
elif (l[0] == '52 95'):
    print(551)
elif (l[0] == '50 122'):
    print(566)
elif (l[0] == '0 1'):
    print(1000)
elif (l[0] == '439 614'):
    print(349)
else:
    print(342)
```
   可以很直观的看出，这是一段“面向用例”的代码。
   所以，我们可以通过对if的使用情况，列如数量是否与用例数差不多，以此来找出“面向用例“的代码。   

   但是if else print的使用情况不是面向用例的代码本质特征，比如 2064，将罗马数字转化成阿拉伯数：
```python
def changeTable(self, str):
    if (str == 'I'):
        return 1
    elif (str == 'V'):
        return 5
    elif (str == 'X'):
        return 10
    elif (str == 'L'):
        return 50
    elif (str == 'C'):
        return 100
    elif (str == 'D'):
        return 500
    elif (str == 'M'):
        return 1000
```
   这是正常的处理部分。
   
   也就是说，纯if else结构分析容易造成个别题目的误判，我们必须设法找出两种if的区别.
       
       方法1: if 里面的判断，和某个input相似；执行的代码块，和output相似。
       
       方法2：研究去掉一个if的body（代码块）会对整体程序有什么影响：如果去除一个if后,仅仅错一个用例；去除另一个if,错另一个用例，就有面向用例的嫌疑了。相反，如果去除了if导致所有的用例都挂了，甚至代码崩溃，说明这个if是程序 正常、关键的结构分支

- 最终我们为了避免和(1)信息相似度匹配重合，采取了方法2：

- 当然而面向用例也有使用字典dict()的，代码里面不含if。因此，我们仅将if else的匹配作为对(1)的补充。

- 虽然if else只是（1）的补充，但是本身还是很有使用价值的和参考价值的.
  我们可以通过先对if else的分析快速找出可疑的“面向用例”的代码，再和（1）的信息相似度结合分析就可以找出“面向用例”的代码


## 三、代码说明

### 1.代码开源地址

https://github.com/huangmengbin/UserCase-Oriented-Detection

### 2.代码目录说明

1. foo：转换test_data.json文件的储存格式。让最终下载的文件的格式是：按照题目下载，每个题目放入同一个文件夹，文件夹内是每个人做的代码文件。

2. gui：用来展示的gui界面代码

3. Resources：下载的代码、转化下载的代码的文件格式储存。下载代码的json文件。

- 给出的test_data.json的格式是user然后其中包含这个user的所有题目。我们做的更改是把格式改为：题目放在最先层，然后每个题目中包含了所有做这个题的同学的代码。
- 根据更改后的新json文件来下载文件
- 对于下载的文件，把多余的信息去掉，只留下每个同学的答题代码。当然，不用Python写的代码就被我们删掉了

4. String_match：提取下载的数据来与用例匹配

5. Structural_analysis：主要是分析代码中的if_else（因为“面向用例”大多都会用到大量的if_else）

6. Time_analysis：限制代码运行时间的修饰器


## 四、研究方法

分为 字符串模糊匹配法 和 if_else分析法

### 字符串模糊匹配法

#### 1.数据获取

##### 代码数据抽取

0. 我们需要提取代码里面的常量数据，包括num数字类型、str字符串类型，避免无关文本信息(如：print、append、def)的干扰

1. 用ast解析源代码，根据解析出来的抽象语法树，提取出有效常量信息作为该代码的关键词，放入一个message列表。

##### 样例数据加工

2. 对于较长的output，拆成列表，为了提高算法效率，可以适当牺牲精确度。提取前面部分有效成分作为其关键词列表，一般是67个左右，总字符数不超过300。

3. 对于较长的input，拆成列表，分别提取头、尾部分有效成分，分别进行分析，类似output。


#### 2.数据匹配

- 匹配：

    对message列表，也是为了效率，选择其所有总字符长度不超用例总字符数2倍的子序列，分别聚合成字符串，再与用例进行比较。比较算法是Jaro-Winkler distance，是由William E. Winkler在Jaro distance的基础上进一步改进的算法，用于求解两个字符串之间的相似性，并且对公共前缀的权重有所提高。
    返回所有相似度的最大值，以及对应子列表的始末下标，为了以后给该段信息标红。若最大值有多个，则所有始末下标都要返回。
    经验证Jaro-Winkler 与 jaro算法差别不大， 比编辑距离算法更准确

#### 3.数据处理

1. 以上仅为单个用例的相似度，要得出最终结果，需要进一步处理。

2. 首先，定义检测的有效度，代表结果的可信性。若用例极其短，甚至仅包含“ok” “0” “True”，即使十分相似，完全匹配，也是不可信的。而长的用例，基本一旦匹配就是面向用例，不匹配一般就认定是面向用例了。有效度根据用例列表的列表长度、字符串总长度、字符串平均长度，字符串最大值综合计算得出，绝大部分是根据用例决定。它和相似度无必然联系，大概就是给予了一个‘弃权’的机会。

3. 然后根据所有输入输出的相似度、有效度，计算出总相似度、有效度. 一般来说，output匹配比input更优先一些。总相似度为各相似度根据对应有效度进行加权，从而算出的平均值。

### if_else分析法

#### 1.数据获取
1. 首先把下载下来的文件中的代码读取出来。通过ast.parse方法对代码进行分析。得到代码的抽象语法树
2. 通过Python带的ast中的walk方法对代码进行分析，找出所有的if节点，并存入一个allIf表中。
3. 提取解析用例，把每个用例的input存储在testInput中，output存储在testOut中
4. 最后依次把allIf表中的if中的body部分清空，再运行代码，用sys.stdout跟testOut比较正确情况，用0代表错误1代表正确。这样，每清空一个if的body就可以得到一个0、1的list，最终得到一个0、1的矩阵。
5. 当然，对if的次数也进行分析，因为如果if次数与用例的个数差不多的话，就是有“面向用例”的嫌疑的

#### 2.分析矩阵

- 矩阵预处理：
    1. 把矩阵中全1的行删除，因为这说明这个if对所有用例的output没有影响
    
    2. 对于某个input，如果这段代码原来的执行情况就是错误的话，那么就需要把矩阵中相对应的列删掉
    
- “面向用例”分析：
    1. 首先判断if的数量与用例的数量之差的绝对值，如果数值过大（大于等于3）则可以排除（但是这个方法不一定正确，因为只分析了if else）
    
    2. 找出矩阵中0的个数比较多（大于等于2）的行，这些行代表if影响的用例比较多。如果这些行的个数较多的话，就基本可以判定为没有“面向用例”

    3. 找出矩阵中0的个数只有一个的行数，这些行代表这个if只影响了一个用例的output，如果这些行数和用例数差不多则很大概率可以判定为是“面向用例”
    
## 五、其他的工具包

### 1.时间限制
运用Package func_timeout中的func_set_timeout(time)的方法可以避免终止运行中的超时问题

### 2.gui展示
通过字符串模糊匹配法、if_else分析法得到的数据，在gui中展示出来，可以让使用者很直观的看到一些“面向用例”的情况

## 六、使用的自带库or开源库

1. ast  用于编译代码成抽象语法树
2. astunparse  反编译用的，结合上面那个东西进行 删除注释 操作  ( x )  
3. matplotlib.pyplot  数据可视化：画柱状图  
4. Levenshtein  算两个字符串的编辑距离、jaro距离
5. func_timeout  一个限定函数执行时间的注解
6. tkinter  py自带的gui


## 七、案例分析

2216_数字操作_分数加减运算
![d](./001.jpeg)


## 八、本项目的优势与局限

### 优势
1. 采用字符串模糊匹配法来计算 源代码和样例的信息相似度，抓住了面向用例的本质特征
2. 预处理充分，不仅删除了注释、空行，还对源码关键信息进行提取，也有对长expect output的分割，这样统一了两者的数据格式，遗漏率和误判率都有效降低
3. 能适应各种题目场景，有的题目要求的输出是['c','z','y','i','s',6,6,6]之类的答案，而面向用例写法有很多种，即使难以对expect output进行分割，也能满足需求
4. 能适应同学们的各种‘骚操作’，比如dict()打表，对输出疯狂split join append +=, 都能有效识别出，这是精确匹配、正则表达式难以完成的
5. ui中可以清晰的查看每道题的做题人的代码，并且可以标记可疑的数据。也可以人工地判断代码是否“面向用例”。也可以通过字符串模糊匹配法的表和if_else分析法的表来查看本道题的“面向用例”情况
6. if else：对于用if....:print(...)  elif.....:print(...) ........  else:print(....)来“面向用例”的代码，可以在字符串模糊匹配法的基础上进一步判断“面向用例”情况

### 局限
1. 对个别短、特殊性强的expect output的方法识别不足，假如某道题只有一个用例，只需要print('ok')就能满分。而正常作答的代码一般也有if(xxx):print('ok')之类的东西，就难以区分。
2. 不能适应部分同学对数据进行utf8‘加密’。
3. 对同学们的代码计算出面向用例程度并排序后，一般的确是面向用例的得分总体比正常作答的高，难以自动找出分割的那个数据：究竟是0.8以上算面向用例，还是0.85分？并且不同题目的数值不同。
4. 两种分析法都会有误判的时候。比如一部分同学写的代码是写完之后发现有个别用例过不了，才选择“面向用例”的，这样的难以发现。

## 九、想说的话

	上了一学期的网课，感受十分不好。希望期末考老师助教小哥哥小姐姐手下留情。
	
	也很遗憾没能和有趣可爱的陈老师见面。。。。。。。。。

    院里个个都是人才啊，面向用例的时候，啥骚操作加密都有，真是令人‘赞不绝口’。
    
    感谢大家给我们提供了那么优质的数据，让我们学习到数据挖掘、数据相似检测、数据分析、数据可视化相关的知识。  
    
## 附录

    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip
    用例数=
    4
    ==================
    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip\user_49823_score_100.py
    if数量=
    3
    未删if前，通过=[1, 1, 1, 1]
    
    [0, 0, 0, 0]
    [0, 0, 0, 0]
    [0, 0, 0, 1]
    ==================
    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip\user_59018_score_100.py
    if数量=
    3
    未删if前，通过=[1, 1, 1, 1]
    
    [0, 1, 1, 0]
    [0, 0, 0, 0]
    [0, 0, 1, 1]
    ==================
    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip\user_60580_score_100.py
    if数量=
    2
    未删if前，通过=[1, 1, 1, 1]
    
    [0, 1, 1, 0]
    [0, 1, 0, 0]
    ==================
    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip\user_60586_score_100.py
    if数量=
    3
    未删if前，通过=[1, 1, 1, 1]
    
    [1, 0, 1, 1]
    [1, 1, 1, 0]
    [0, 1, 1, 1]
    ==================
    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip\user_60589_score_100.py
    if数量=
    1
    未删if前，通过=[1, 1, 1, 1]
    
    [0, 1, 1, 0]
    ==================
    D:\czyFile\2216_数字操作_分数加减运算_1578295739758.zip\user_60901_score_100.py
    if数量=
    10
    未删if前，通过=[1, 1, 1, 1]
    
    [1, 1, 1, 0]
    [1, 1, 1, 1]
    [1, 1, 1, 1]
    [0, 1, 1, 1]
    [1, 1, 0, 1]
    [1, 1, 1, 1]
    [1, 1, 1, 1]
    [1, 0, 1, 1]
    [1, 1, 1, 1]
    [1, 1, 1, 1]
    ==================