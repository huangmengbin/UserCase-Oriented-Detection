# 数据科学大作业

## 一、小组信息：


### 1.小组人数： 3人
### 2.成员信息
	181250051_黄孟斌_181250051@smail.nju.edu.cn  Python完成题数185  
	json数据格式转换、删除重复数据、字符串模糊匹配 、if_else结构分析、gui界面  
	
	181250029_段晓文_181250029@smail.nju.edu.cn  Python完成题数177  
	ppt、数据可视化、gui界面  
	
	181250179_袁易锋_181250179@smail.nju.edu.cn  Python完成题数200 
	数据下载、数据解压缩、if_else结构分析


## 二、研究问题：“面向用例”检测

### 1.研究背景
- 在本次的200道Python练习题中，因为结果显示中可以看到正确的答案，所以就可以通过简单的方法来获取一对对的用例和相应的结果，在这样的情况下就可以通过判断来确定一个输入对应的是什么答案。这就是“面向用例”编程。  
- 在某些情况下，把所有用例都放出来有利于同学们进行编程、debug。尤其是算法题太多太难，不知道bug在哪里容易让学生产生自闭的情绪  
- 放出用例是有必要的，尤其是有的测试用例本身就有错漏。不放出用例，学生不知道用例有误，很可能拼命寻找本不存在的bug，知道真相后可能导致精神崩溃  
- 但放出用例给予了钻空子的可能。而面向用例编程是我们不愿意看到的，它不能反映同学们的正常水平，也浪费同学们的时间  
- 我们组本次的研究问题就是通过一定的方法来检测出这些“面向用例”的代码  

### 2.应用场景
- 分析同学们的代码，查看出同学们有没有用“面向用例”的方法来投机取巧，为了通过测试不择手段  
- 限制下一届筒子进行面向用例编程，使得助教xggxjj们能够继续把用例放出来，提升筒子们写代码的体验；同时也让同学们能真正锻炼到编码能力

### 3.研究思路

- (1).面向用例的代码本质特征是：源代码重有大量与测试样例重合的部分。因此可以尝试源代码与测试样例文本的信息相似度匹配。

- (2).if elif print的使用情况不是面向用例的代码本质特征，比如 2064，将罗马数字转化成阿拉伯数：
```python
def changeTable(self, str):
    if (str == 'I'):
        return 1
    elif (str == 'V'):
        return 5
    elif (str == 'X'):
        return 10
    elif (str == 'L'):
        return 50
    elif (str == 'C'):
        return 100
    elif (str == 'D'):
        return 500
    elif (str == 'M'):
        return 1000
```
这是正常的处理部分。而面向用例也有使用字典dict()的，代码里面不含if

- 因此，我们仅将if else的匹配作为(1)的补充。

## 三、代码说明

### 1.代码开源地址

https://github.com/huangmengbin/UserCase-Oriented-Detection

### 2.代码目录说明

1. foo：转换test_data.json文件的储存格式。让最终下载的文件的格式是：按照题目下载，每个题目放入同一个文件夹，文件夹内是每个人做的代码文件。

2. gui：用来展示的gui

3. Resources：下载的代码、转化下载的代码的文件格式储存。下载代码的json文件。

4. String_match：提取下载的数据来与用例匹配

5. Structural_analysis：主要是分析代码中的if_else（因为“面向用例”大多都会用到大量的if_else）

6. Time_analysis：限制代码运行时间的修饰器


## 四、研究方法

分为 字符串模糊匹配法 和 if_else分析法

### 字符串模糊匹配法
#### 1.数据获取
1. 给出的test_data.json的格式是user然后其中包含这个user的所有题目。我们做的更改是把格式改为：题目放在最先层，然后每个题目中包含了所有做这个题的同学的代码。
2. 根据更改后的新json文件来下载文件
3. 对于下载的文件，把多余的信息去掉，只留下每个同学的答题代码。当然，不用Python写的代码就被我们删掉了

#### 2.数据匹配

- 数据提取：

根据解析出来的ast树，提取出有效常量信息作为该代码的关键词，放入一个message列表。

对于较长的output，拆成列表，为了提高算法效率，可以适当牺牲精确度。提取前面部分有效成分作为其关键词列表，一般是67个左右，总字符数不超过300。

对于较长的input，拆成列表，分别提取头、尾部分有效成分，分别进行分析，类似output。

- 匹配：

对message列表，也是为了效率，选择其所有总字符长度不超用例总字符数2倍的子序列，分别聚合成字符串，再与用例进行比较。比较算法是Jaro-Winkler distance，是由William E. Winkler在Jaro distance的基础上进一步改进的算法，用于求解两个字符串之间的相似性，并且对公共前缀的权重有所提高。
返回所有相似度的最大值，以及对应子列表的始末下标，为了以后给该段信息标红。若最大值有多个，则所有始末下标都要返回。
经验证Jaro-Winkler 与 jaro算法差别不大， 比编辑距离算法更准确

- 数据处理：

以上仅为单个用例的相似度，要得出最终结果，需要进一步处理。

首先，定义检测的有效度，代表结果的可信性。若用例极其短，甚至仅包含“ok” “0” “True”，即使十分相似，完全匹配，也是不可信的。而长的用例，基本一旦匹配就是面向用例，不匹配一般就认定是面向用例了。有效度根据用例列表的列表长度、字符串总长度、字符串平均长度，字符串最大值综合计算得出，绝大部分是根据用例决定。它和相似度无必然联系，大概就是给予了一个‘弃权’的机会。

然后根据所有输入输出的相似度、有效度，计算出总相似度、有效度. 一般来说，output匹配比input更优先一些。总相似度为各相似度根据对应有效度进行加权，从而算出的平均值。



### if_else分析

首先把下载下来的文件中的代码取出来。通过ast.parse方法对代码进行分析
通过Python带的ast的方法对代码进行分析，找出所有的if节点，并存入一个allIf表中。
提取解析用例，把每个用例存储在testInput中，结果存储在testOut中
最后把依次把if中的body部分清空，再运行代码，用sys.stdout跟testOut比较正确情况。这样就可以得到一个0,1的矩阵，通过分析这个矩阵就可以基本判断该代码是不是“面向用例”的代码
当然，对if的次数也进行分析，如果if次数与用例的个数差不多的话，就是有“面向用例”的嫌疑的

## 五、其他的工具包

### 1.时间分析
运用Package func_timeout中的func_set_timeout(time)的方法可以避免终止运行中的超时问题


### 2.gui展示
通过上述方法得到的数据，在gui中展示出来，可以让使用者很直观的看到一些“面向用例”的情况

## 六、使用的开源库

1. ast  用于编译代码成抽象语法树
2. astunparse  反编译用的，结合上面那个东西进行 删除注释 操作  ( x )  
3. matplotlib.pyplot  数据可视化：画柱状图  
4. Levenshtein  算两个字符串的编辑距离、jaro距离
5. func_timeout  一个限定函数执行时间的注解
6. tkinter  py自带的gui


## 七、案例分析






## 八、本项目的优势与局限



## 九、想说的话

	上了一学期的网课，感受十分不好。希望期末考老师助教小哥哥小姐姐手下留情。
	也很遗憾没能和有趣可爱的陈老师见面。。。。。。。。。

    院里个个都是人才啊，面向用例的时候，啥骚操作加密都有，真是令人‘赞不绝口’。
    
    感谢大家给我们提供了那么优质的数据，让我们学习到数据挖掘、数据相似检测、数据分析、数据可视化相关的知识。  
    
## 附录



